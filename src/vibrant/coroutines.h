#ifndef ORIGINAL_COROUTINES_H
#define ORIGINAL_COROUTINES_H
#include "optional.h"
#include <coroutine>
#include <exception>

/**
 * @file coroutines.h
 * @brief C++20 coroutine support with generator pattern implementation
 *
 * This file implements a type-safe, lazy-evaluation generator pattern using
 * C++20 coroutines. The generator provides a convenient way to create and
 * consume sequences of values with minimal memory overhead and efficient
 * suspension/resumption semantics.
 *
 * Key Features:
 * - Lazy evaluation: Values are generated on-demand
 * - Exception safety: Proper exception propagation through coroutine boundaries
 * - Iterator support: Compatible with range-based for loops and STL algorithms
 * - Move semantics: Efficient transfer of coroutine state
 * - Resource management: Automatic cleanup of coroutine handles
 * - Type safety: Compile-time type checking for generated values
 *
 * @note The generator suspends after each yielded value, allowing consumers
 *       to control the execution flow and memory usage.
 * @note Coroutine state is automatically destroyed when the generator goes
 *       out of scope, preventing resource leaks.
 */

namespace original {
    /**
     * @class coroutine
     * @brief Namespace for coroutine-related utilities and generator implementation
     * @details Provides a generator class template that implements the C++20 coroutine
     *          protocol for creating lazy sequences of values.
     */
    class coroutine {
    public:
        /**
         * @class generator
         * @tparam TYPE Type of values generated by the coroutine
         * @brief Lazy sequence generator using C++20 coroutines
         * @details Implements the coroutine promise protocol to create generators
         *          that can yield sequences of values. Supports range-based for loops,
         *          manual iteration, and exception propagation.
         *
         * The generator maintains the following states:
         * - Suspended: Waiting to be resumed (initial and after each yield)
         * - Running: Currently executing coroutine logic
         * - Completed: All values have been generated
         *
         * @note Generators are move-only types to prevent accidental copying of
         *       coroutine state.
         * @note Iterators become invalid when the generator is destroyed or moved.
         */
        template<typename TYPE>
        class generator {
            /**
             * @struct promise_type
             * @brief Implements the coroutine promise interface for generator
             * @details Manages the coroutine state, value storage, and exception
             *          handling according to the C++20 coroutine specification.
             */
            struct promise_type {
                bool initial_staus = false;      ///< Tracks if coroutine has started execution
                alternative<TYPE> value_;        ///< Storage for the current yielded value
                std::exception_ptr e_;           ///< Captured exceptions for propagation

                /**
                 * @brief Creates the generator object from this promise
                 * @return generator instance associated with this promise
                 */
                generator get_return_object();

                /**
                 * @brief Defines initial suspension behavior
                 * @return suspend_always to start in suspended state
                 * @note Lazy initialization: coroutine starts suspended
                 */
                static std::suspend_always initial_suspend();

                /**
                 * @brief Defines final suspension behavior
                 * @return suspend_always to keep frame alive for cleanup
                 * @note Prevents automatic destruction of coroutine frame
                 */
                static std::suspend_always final_suspend() noexcept;

                /**
                 * @brief Handles coroutine completion without value
                 */
                static void return_void();

                /**
                 * @brief Handles value yielding from coroutine
                 * @param value Value to yield to caller
                 * @return suspend_always to suspend after yielding
                 * @note Stores the value and suspends execution
                 */
                std::suspend_always yield_value(TYPE value);

                /**
                 * @brief Captures exceptions thrown from coroutine
                 */
                void unhandled_exception();

                /**
                 * @brief Re-throws any captured exception
                 * @throws The exception previously captured by unhandled_exception
                 */
                void rethrow_if_exception() const;
            };

            /**
             * @class iterator
             * @brief Input iterator for generator range-based operations
             * @details Provides input iterator interface for using generator
             *          with range-based for loops and STL algorithms.
             *
             * Iterator invalidation:
             * - Invalidated when generator is destroyed
             * - Invalidated when generator is moved from
             * - Safe for single-pass algorithms only
             */
            class iterator {
                generator* gen_;  ///< Pointer to parent generator
                bool end_;        ///< Flag indicating end iterator

                /**
                 * @brief Default constructor creates end iterator
                 */
                iterator();

                /**
                 * @brief Constructs iterator for specific generator
                 * @param gen Pointer to generator to iterate over
                 */
                explicit iterator(generator* gen);
            public:
                friend coroutine;

                /**
                 * @brief Advances iterator to next value
                 * @return Reference to this iterator
                 * @note Calls generator::next() internally
                 */
                iterator& operator++();

                /**
                 * @brief Dereferences iterator to get current value
                 * @return Current value from generator
                 * @throws nullPointerError if dereferencing end iterator
                 */
                TYPE operator*();

                /**
                 * @brief Checks iterator inequality
                 * @param other Iterator to compare with
                 * @return true if iterators are not equal
                 */
                bool operator!=(const iterator& other) const;

                /**
                 * @brief Checks iterator equality
                 * @param other Iterator to compare with
                 * @return true if iterators are equal
                 */
                bool operator==(const iterator& other) const;
            };

            using handle = std::coroutine_handle<promise_type>;  ///< Coroutine handle type

            handle handle_;  ///< Underlying coroutine handle

        public:
            using promise_type = promise_type;  ///< Promise type for coroutine protocol
            using iterator = iterator;          ///< Iterator type for range operations

            generator(const generator&) = delete;            ///< Copy constructor deleted
            generator& operator=(const generator&) = delete; ///< Copy assignment deleted

            /**
             * @brief Move constructor transfers coroutine ownership
             * @param other Generator to move from
             * @note Source generator becomes empty after move
             */
            generator(generator&& other) noexcept;

            /**
             * @brief Move assignment operator transfers coroutine ownership
             * @param other Generator to move from
             * @return Reference to this generator
             * @note Destroys current coroutine handle before transfer
             */
            generator& operator=(generator&& other) noexcept;

            generator() = default;  ///< Default constructor creates empty generator

            /**
             * @brief Constructs generator from coroutine handle
             * @param h Coroutine handle to manage
             */
            explicit generator(handle h);

            /**
             * @brief Gets begin iterator for range-based operations
             * @return Iterator positioned at first value
             * @note Resumes coroutine to get first value
             */
            iterator begin();

            /**
             * @brief Gets end iterator for range-based operations
             * @return End iterator marker
             */
            static iterator end();

            /**
             * @brief Checks if coroutine has been launched
             * @return true if coroutine has started execution
             */
            [[nodiscard]] bool launched() const;

            /**
             * @brief Checks if generator has more values
             * @return true if next() would return a value
             */
            [[nodiscard]] bool hasNext() const;

            /**
             * @brief Peeks at current value without advancing
             * @return optional containing current value if available
             * @note Does not resume coroutine or change state
             */
            [[nodiscard]] alternative<TYPE> peek() const;

            /**
             * @brief Advances generator and gets next value
             * @return optional containing next value if available
             * @note Resumes coroutine execution and may throw exceptions
             */
            alternative<TYPE> next();

            /**
             * @brief Destructor cleans up coroutine resources
             * @note Automatically destroys coroutine handle
             */
            ~generator();
        };
    };
}

template <typename TYPE>
original::coroutine::generator<TYPE>
original::coroutine::generator<TYPE>::promise_type::get_return_object()
{
    return generator{handle::from_promise(*this)};
}

template <typename TYPE>
std::suspend_always original::coroutine::generator<TYPE>::promise_type::initial_suspend()
{
    return std::suspend_always{};
}

template <typename TYPE>
std::suspend_always original::coroutine::generator<TYPE>::promise_type::final_suspend() noexcept
{
    return std::suspend_always{};
}

template <typename TYPE>
void original::coroutine::generator<TYPE>::promise_type::return_void() {}

template <typename TYPE>
std::suspend_always original::coroutine::generator<TYPE>::promise_type::yield_value(TYPE value)
{
    if (!this->initial_staus) {
        this->initial_staus = true;
    }
    this->value_ = std::move(value);
    return std::suspend_always{};
}

template <typename TYPE>
void original::coroutine::generator<TYPE>::promise_type::unhandled_exception()
{
    this->e_ = std::current_exception();
}

template <typename TYPE>
void original::coroutine::generator<TYPE>::promise_type::rethrow_if_exception() const
{
    if (this->e_)
        std::rethrow_exception(this->e_);
}

template <typename TYPE>
original::coroutine::generator<TYPE>::iterator::iterator() : gen_(nullptr), end_(true) {}

template <typename TYPE>
original::coroutine::generator<TYPE>::iterator::iterator(generator* gen) : gen_(gen), end_(false)
{
    if (!this->gen_) {
        this->end_ = true;
        return;
    }
    ++*this;
}

template <typename TYPE>
original::coroutine::generator<TYPE>::iterator&
original::coroutine::generator<TYPE>::iterator::operator++()
{
    if (this->end_)
        return *this;
    if (auto gen_next = this->gen_->next(); !gen_next) {
        this->end_ = true;
    }
    return *this;
}

template <typename TYPE>
TYPE original::coroutine::generator<TYPE>::iterator::operator*()
{
    if (this->end_)
        throw nullPointerError("Dereferencing end iterator");
    return *this->gen_->peek();
}

template <typename TYPE>
bool original::coroutine::generator<TYPE>::iterator::operator!=(const iterator& other) const
{
    return !(*this == other);
}

template <typename TYPE>
bool original::coroutine::generator<TYPE>::iterator::operator==(const iterator& other) const
{
    if (this->end_ && other.end_)
        return true;
    if (this->end_ != other.end_)
        return false;
    return this->gen_ == other.gen_;
}

template <typename TYPE>
original::coroutine::generator<TYPE>::generator(generator&& other) noexcept
{
    this->handle_ = other.handle_;
    other.handle_ = nullptr;
}

template <typename TYPE>
original::coroutine::generator<TYPE>&
original::coroutine::generator<TYPE>::operator=(generator&& other) noexcept
{
    if (this == &other) {
        return *this;
    }

    if (this->handle_) {
        this->handle_.destroy();
    }

    this->handle_ = other.handle_;
    other.handle_ = nullptr;
    return *this;
}

template <typename TYPE>
original::coroutine::generator<TYPE>::generator(handle h) : handle_(std::move(h)) {}

template <typename TYPE>
original::coroutine::generator<TYPE>::iterator
original::coroutine::generator<TYPE>::begin()
{
    return iterator{this};
}

template <typename TYPE>
original::coroutine::generator<TYPE>::iterator
original::coroutine::generator<TYPE>::end()
{
    return iterator{};
}

template <typename TYPE>
bool original::coroutine::generator<TYPE>::launched() const
{
    return this->handle_.promise().initial_staus;
}

template <typename TYPE>
bool original::coroutine::generator<TYPE>::hasNext() const
{
    return this->handle_ && !this->handle_.done();
}

template <typename TYPE>
original::alternative<TYPE> original::coroutine::generator<TYPE>::peek() const
{
    return this->handle_.promise().value_;
}

template <typename TYPE>
original::alternative<TYPE>
original::coroutine::generator<TYPE>::next()
{
    if (!this->hasNext())
        return alternative<TYPE>{};

    this->handle_.resume();
    this->handle_.promise().rethrow_if_exception();

    if (!this->hasNext())
        return alternative<TYPE>{};

    return this->handle_.promise().value_;
}

template <typename TYPE>
original::coroutine::generator<TYPE>::~generator()
{
    if (this->handle_)
        this->handle_.destroy();
}

#endif //ORIGINAL_COROUTINES_H
